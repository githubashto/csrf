# csrf
csrf: токены не нужны?
بسم الله الرحمن الرحيم‎‎ 

<blockquote><i>Для защиты от CSRF вы должны использовать анти-CSRF токены и только их. </i> &#169; @pyrk2142 
<a href="http://habrahabr.ru/post/235247/">Типичные ошибки при защите сайтов от CSRF-атак</a></blockquote>

Попытался привести мысли в порядок, нарвался на бардак в интернете, пришлось задуматься. Результат размышлений излагаю.
Картинок не будет, предполагается что читатель достаточно знаком с темой, что бы сложить все происходящее в красивые схемы у себя в голове.
<habracut/>
И еще. Коллеги, если при прочтении статьи у вас на каком либо моменте возникает яростное несогласие со мной - не торопитесь писать разоблачительные комментарии - дочитайте пожалуйста статью до конца. Я излагал мысли по мере их возникновения и в ходе осмысления тоже менял отношение к ним.   

Что мы подразумеваем под csrf атакой?
<blockquote>Вольный пересказ вики:
CSRF (англ. Сross Site Request Forgery — «Межсайтовая подделка запроса», также известен как XSRF) — вид атак на посетителей веб-сайтов. Жертва, авторизованная на сайте А(target), заходит на сайт В(зловред), в ходе просмотра которого код, внедренный в страницу сайта В отправляет запрос к сайту А. Поскольку пользователь авторизован на сайте А, при отправке запроса передаются куки, таким образом сайт А предполагает что запрос порядочный и выполняет его. Сайт А в этой ситуации признается уязвимым к csrf атаке.</blockquote>
Вводная:
<ul>
	<li> javascript в броузере пользователя включен</li>
        <li> <s>броузер отправляет/принимает (и обрабатывает) http headers согласно спецификациям</s> (не пригодилось)</li>
  <li>уязвимости броузеров не принимаем во внимание</li>
  <li>отклонения от стандартов в поведении броузеров принимаем во внимание</li>
  <li>сайт А - работает только по https, перехват трафика не рассматривается</li>
</ul>

Как предлагается защищаться от атаки <a href="https://www.google.ru/?q=%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0+%D0%BE%D1%82+csrf">в интернетах</a>?
<p>Генерируем токен (мандат), прикручиваем его к форме (скрытым полем) и при отправке запроса на сервер передаем в том числе и его.
На сервере проверяем валидность токена (и возможно на какой вид операции выдан) и если все в порядке - выполняем запрос, иначе с негодованием отвергаем.
Как это работает? Когда зловред формирует запрос к сайту A(через страницу сайта В, открытую в броузере авторизованного на сайте А клиента), броузер автоматически передает при запросе куку (пользователь то авторизован). Соответственно помимо куки должен быть секрет, не передающийся автоматически серверу (то есть не хранящийся в куках) и недоступный зловреду. Это и есть токен.</p>

То есть токен служит гарантией того, что запрос сформирован контролируемым нами кодом. Есть ли другие способы понять, какой код сформировал запрос? Да, есть один, и он до безобразия прост.
<b>HTTP Referer</b> 
Проверяя реферер, мы гарантированно отсеиваем запросы, сформированные не с наших страниц. Так ли это?
В интернетах полно утверждений что этот способ ненадежен, так как реферер легко подделать. Это, мягко говоря, не так. Давайте не будем выпадать из контекста - зловреду надо подделать запрос из броузера, в котором сидит авторизованный на нашем сайте клиент. Так вот, этот реферер зловред подделать не может. Либо уйдет реферером url зловредного сайта либо пустой реферер. Если мы на своей стороне (на сервере) делаем проверку сессии (куки) и реферера (на принадлежность нашему домену) отсеивая пустые и левые рефереры - то злоумышленик не сможет просочиться.
Именно обработка пустых рефереров влияет на надежность схемы: отбрасываем - схема надежная, принимаем - подставляем клиента. Именно многочисленные реализации второго сценария сформировали мнение о слабости схемы.
А как же быть с подделкой реферера? Она есть и это факт. Но зловред может подделать реферер только со своего компа (подконтрольного), на котором не будет сессии (куки). Таким образом злоумышленник не может собрать в одном месте поддельный реферер и куку сессии для осуществления поддельного запроса. <b>Схема надежная, токены не нужны</b>. Это одна из двух схем, которые я пока что выбрал для себя. Итого:

<b>Решение #1</b>
Смотрим реферер, если пустой или не наш домен - шлем в лес. Для проектов без cross domain requests, небольшая часть пользователей (пара процентов) испытает неудобства. Можно разрешить CORS и вести wite list доверенных доменов.

Но эта схема не подойдет для проектов, принимающих запросы с неограниченного числа сайтов (cross domain ajax, например кнопка like у facebook и тому подобное).

Тут из зала раздается вопрос - как быть с пользователями, чьи рефереры не доходят до сервера? Да, есть такое утверждение. Оно кочует в интернетах, на моей памяти, лет уже как десять. Ходят слухи, что есть прокси, которые режут хидеры и реферер не проходит. Остается загадкой, как проходит тогда кука, ну да ладно. На мой взгляд, тот процент посетителей без хидеров формируется из:
<ul>
<li>зашли по ссылке из закладок (на статейниках такое сплошь и рядом)</li>
<li>серфят в анонимном режиме (самая большая, на мой вгляд группа)</li>
<li>открыли ссылку в письме с почтового клиента (мало таких, но есть. Особенно если вы продвигаете сайт спамом)</li>
<li>боты. Не только яндекс и гугл, в сети есть сотни проектов, индексирующих интернеты. (да, не стоит недооценивать сеошников)</li>
<li>прокся порезала хидер (наверно есть и такие)</li>
</ul>
По хорошему нужен обзор проксей (ПО) с дефолтными настройками на предмет резки заголовков, а также настройки, которые к этому приводят с пониманием, зачем именно такие настройки нужны. Такого обзора не нашел, кто составит - буду благодарен. А пока примем за данность что такие прокси есть и пользователи, которые сидят за ними - для нас важны.

Ок. То есть реферер роли не играет (мы хотим обслуживать клиентов без реферера). В этом случае <b>токен нужен</b>. Но! Есть нюансы.
Первое, второе и десерт - на каком этапе появляется токен, как долго живет и где хранится?
Множество ресурсов рекомендует создавать токен при авторизации и использовать его на время сессии. То есть токен, получается, брат-близнец куки, просто хранится в другом месте. Нормальное такое решение. Все меняется когда приходят они. Нюансы.
Как долго живет сессия? Если до момента закрытия страницы, то все нормально. Закрыли страницу, сессия померла, при повторном открытии требуется авторизация, после прохождения которой будет выдан токен.
Что если мы хотим запомнить пользователя надолго? При закрытии страницы кука остается, при повторном открытии  страницы пользователь авторизован, все довольны. Вопрос - откуда взять токен? Этот же вопрос возникает при переходе на другую страницу авторизованным пользователем. Отдать токен в теле страницы при открытии? Тогда мы откатываемся к началу, так как - если мы отдаем верстку страницы с токеном при запросе авторизованного пользователя, то мы отдадим токен зловреду, который запросит ее через авторизованного пользователя, отпарсит страницу, вытащит токен и сформирует злозапрос. То есть в этой ситуации вместо одного запроса для совершения злодеяния потребуется два. Не более того. Но! Это праведливо если мы разрешили cross domain requests через <a href="https://ru.m.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>. Если CORS не нужен, то все в порядке. То есть:

<b>Решение #2</b>
На реферер не смотрим, генерим токен при авторизации, прибиваем гвоздями к верстке, время жизни куки - до закрытия страницы. Cross domain requests, CORS, (см. ниже) - влияния на безопасность не оказывает. Годится для одностраничных web-приложений. При перезагрузке страницы необходима повторная авторизация (либо см. решение #3)

<b>Решение #3</b>
На реферер не смотрим, генерим токен при авторизации, прибиваем гвоздями к верстке, время жизни куки - любое. Cross domain requests, CORS, (см. ниже) - запрещены. При загрузке страницы авторизованным клиентом токен повторно прибивается к верстке. Годится для многостраничников.

<i>Тут хочу отметить деталь в работе CORS. Атака зловреда сорвется именно из-за токена а не из-за запрещенного CORS. Первый запрос на чтение страницы с мандатом пройдет до сервера и ВЫПОЛНИТСЯ им (если мы не обрабатываем хидер origin до обработки запроса), ответ вернется клиенту, но не отдастся злоскрипту, таким образом тот не сможет выделить токен. Если мы работаем без токена, то запрет CORS нас никак не спасет - зловред может сформировать запрос, который дойдет до сервера и выполнится им, просто  зловреду не видно будет ответа сервера, что не всегда и нужно. Так что хинт: не пренебрегайте вниманием к хидеру origin. В нашем случае это синоним реферера. Казалось бы - а зачем? Да, на безопасность в этом сценарии не влияет, но проверка origin (как и реферер) до обработки позволит отклонять левые запросы без их обработки. Может влиять на производительность ( например от имени авторизованного пользователя зловред может запустить ядреный поиск, недоступный не авторизованным пользователям. Результат не увидит, а вот серваку вашему возможно придется покряхтеть винтами)</i>

Но вот нам в голову приходит светлая мысль улучшить не только наш сайт но и весь интернет и мы начинаем распространять новый модный сервис с кнопочками, лайками и фоловами.
То есть надо разрешить CORS. О, в этот момент все преображается и начинает играть новыми красками!
Как только мы разрешаем CORS, мы теряем возможность хранить токен в верстке страницы (см. выше). Но хранить его где-то надо. Надеюсь, отчаянность мысли хранить токен в куках объяснять не надо.
Путем нехитрых умозаключений приходим к простому пониманию - транспортировка данных от сервера до клиента у нас идет по двум маршрутам - http headers и верстка страницы (либо json ответ, в данном контексте не важно). Все, других путей нет. Хидеры отпадают (да, XMLHTTPRequest дает доступ к хидерам от сервера, но все что можем прочитать мы - прочитает зловред), остается верстка. Но в верстку тоже нельзя, мы уже разобрали тот момент, в котором зловред вытаскивает токен от имени авторизованного пользователя. То есть авторизованному пользователю отдавать токен нельзя. А не авторизованному? Вооот! Единственный момент, когда мы безопасно можем отдать токен - это неавторизованному пользователю в момент авторизации, когда мы получаем от него логин и пароль. До этого момента он для нас никто, после этого момента (после выставления куки) - он для нас зловред.
А где хранить токен? Не в верстке и не в куках. LocalStorage вполне подойдет. Итого:

<b>Решение #4</b>
Генерим токен только при авторизации. Скриптом сразу кладем в localStorage, при каждом action добавляем токен в форму (можно повесить на обработчика submit)
Неограниченный круг лиц и доменов, рефереры не важны, спим спокойно. Годится для одностраничников, многостраничников, при генерации верстки на сервере, на клиенте. В общем серебряная пуля. Ок.
Довольный результатом, я зашел в redmine, оформил все заметками в вики и продолжил работу над проектом. Но мозг не унимался, осталась какая то незавершенность в вопросе.
Перечитав все несколько раз, глаз зацепился за фразу про то что токен - брат-близнец куки, просто хранится в другом месте. Ок. А что если он не брат-близнец, а клон куки? То есть такой момент. Отдавая токен серверу, мы ведь фактически подтверждаем не факт владения секретом (эту функцию выполняет кука) а факт управления процессом, то есть контроль над транспортом. Ведь фактически, если мы не будем генерить токен, а возьмем куку (на клиенте), скриптом вставим ее в передаваемые параметры - что изменится? НИЧЕГО! Зловред не сможет это повторить! Давайте заново. Зловред не может прочитать нашу куку, но может инициировать ее передачу серверу при запросе, передачу в хидере! Это важно. Но он не может прочитать эту куку и передать ее в параметре формы. А мы можем! Итого:

<b>Решение #5</b>
Токены не нужны (в смысле их генерация и валидация) На клиенте - перед каждым запросом читаем куку и добавляем ее в параметр запроса. На сервере - сравниваем куку с параметром запроса, если совпадают - дальнейшие проверки (факт авторизации, права и прочее). Но! В этом случае мы вынуждены отказаться от Http-only кук и открыть доступ на чтение куки javascript-у. XSS-фобам это может не понравится.

 <i>Что же, пораскинем. Можно не убирать Http-only, а отдавать сгенерированный session id при авторизации и в куку и в скрипт, который ее сразу положит в localStorage. А дальше - также как и в решении #5. Ок? Нет. Сохранение куки в localStorage равносильно отмене Http-only с точки зрения XSS-атаки.</i>

<spoiler title="update. осторожно, криптография">
мне тут подсказывают, что куки может бы две, одна доступна для чтения, другая нет. А токен может быть хэшем от session_id. Хорошие мысли!
итого. Две куки, одна доступна для чтения javascript. Мы защищены от XSS, продолжаем защищаться от csrf. Так вот, мысль следующая. На сервере при авторизации генерим некий id, также, как и для сессии. Но не отдаем его, а удваиваем (складываем строку саму с собой) и пропускаем через rc4, со своим паролем, который лежит только на сервере.
Далее - первую половину делаем кукой сессии, вторую - кукой токена.
На клиенте, как и обсуждалось - скриптом подтягиваем куку токена и передаем либо в форме либо в заголовке.
На сервере при проверке - складываем токен и куку сессии, прогоняем через rc4 и сравниваем. Если совпадает - токн верный, проверяем куку сессии на валидность, разворачиваем сессию. Если нет - шлем в лес.
В чем преимущество? Во первых минимальный оверхед. Как я уже указал в комментах, минимум операций на каждый байт, ни в какое сравнение с md5 или sha. Реально применимо для хайлоада. Кроме того, после того, как мы сравнили токен и куку сессии, мы достоверно знаем что клиент авторизован. Мы не знаем кто он, но знаем что авторизован. При этом не обращаясь ни к memcached, ни к sql, не разворачивая сессию. Это очень удобно для действий, доступных всем авторизованным пользователям.

в общем пришел вот к такому коду для node/io.js (черновик):
<source lang="JavaScript">
var key = "пишем сюда наше ключевое слово для генератора (ascii), не более 256 байт";
var offset = "смещение, 256, 512, 1024, для усиления стойкости. значение не влияет на быстродействие";
var i, j, x;
var s = [];
//init s
for(i = 0; i < 256; s[i] = i++);

for(i = 0; i < 256; j = (j + s[i] + key[i % key.length]) % 256, x = s[i], s[i++] = s[j], s[j] = x);
//прогоняем s на offset ходов (равносильно отбрасыванию первых n байт шифртекста для усиления кода
i = 0;
j = 0;

while(offset-- > 0) ++i %= 256, j = (j + s[i]) % 256, x = s[i], s[i] = s[j], s[j] = x);

//фиксим s замыканием
var rc4 = function(s){
    return function (str) {
        var res = '';
        var i = 0;
        var j = 0;
        var x;
        var y = str.length;
        while (y < 0) {
            i = (i + 1) % 256;
            j = (j + s[i]) % 256;
            x = s[i];
            s[i] = s[j];
            s[j] = x;
            res += String.fromCharCode(str[y--] ^ s[(s[i] + s[j]) % 256]); 
            //нам нужен hex, переработать. Нужен ли? вообще то да - нам его еще передавать по http.
        }
        return res;
    }
}(s);
//при авторизации
var cipher = rc4(session_id + session_id);
token = cipher.substr(0, cipher.length/2);
cookie.id = cipher.substr(cipher.length/2);
//выставляем куку, отдаем токен любым удобным способом

//при обработке полученного запроса:
cipher = rc4(token + cookie.id);
token = cipher.substr(0, cipher.length/2);
cookie.id = cipher.substr(cipher.length/2);

if(token !== cookie.id){
    //прекращаем обработку запроса
    //например, кидаем 403 статус
    //или throw exception, в зависимости от структуры сервера
}
//здесь нормально работаем, токен честный
//можно выполнять любые действия, которые разрешены авторизованному пользователю без выяснения его персоны

//либо по session_id поднимаем сессию и выясняем, кто он такой
</source>
Спасибо @powerman  @dm9  @lucky_libora .
Прошу высказываться.

Не, не вариант. Зловред сделает xor токена и сессии (зарегистрировавшись на ресурсе), получит тем самым xor первой половины со второй половиной от генератора. и последовательно отксорив с токеном и сессией, получит сам генератор, что позволит ему притворяться авторизованным пользователем. А жаль, мысль красивая была.
В общем здесь <a href="http://habrahabr.ru/post/257873/">продолжение мысли</a>.
</spoiler>
Прикольно! А почему так получилось (о пятом решении)? Поразмышляв, пришел к выводу что это произошло по той причине, что мы сделали из токена полную копию сессионной куки по функционалу, различие лишь в транспорте. Ок. В пятом решении мы отказались от токена в пользу куки, оставив альтернативный транспорт. А если сделать наоборот - отказаться от куки? Тоже вариант. То есть:

<b>Решение #6</b>
Традиционной сессии нет (через http headers). Id сессии генерится при авторизации, скрипт на клиенте при получении id сразу кладет его в local storage и при каждом запросе к серверу добавляет к запросу. Этого достаточно как для поверки авторизации клиента так и для защиты от csrf. Но отказ от http кук не делает это решение более защищенным от XSS чем пятое решение.

Такие вот мысли. 
За бортом остались:
<ul>
<li>обсуждение методов доступа (GET, POST, HEAD, экзотика). Я не использую GET, что бы какой нибудь умник не мог, запостив "картинку" с нужным урлом на посещаемом ресурсе нагрузить мои сервера. В остальном без разницы - все что можем сделать с XMLHTTPRequest мы - может сделать зловред.</li>
<li>протоколы доступа. http я для себя вычеркнул, пока https, поглядываю на wss, но пока внятных мыслей нет. Буду рад комментариям по этой теме.</li>
<li>Разница в правах на броузере клиента между добропорядочным кодом с нашего сервера, подгруженным в страницу зловреда через script src и изначально чужим кодом, делающим запрос к нашему серверу. Хотя да, надо бы тоже подробно посмотреть.</li>
</ul>
В общем для себя я выбрал первый и пятый варианты, но пока не переписываю код, жду когда остынет. Предлагаю обсудить. 
<hr>ссылки по теме:
<ul>
<li><a href="https://learn.javascript.ru/xhr-crossdomain">cross domain requests (rus)</a></li>
<li><a href="http://docs.spring.io/spring-security/site/docs/3.2.0.CI-SNAPSHOT/reference/html/headers.html">http security headers (eng)</a></li>
<li><a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet">поваренная книга защитных рецептов (eng)</a></li>
</ul><hr>
<i>P.S. Если в чем не прав - не стесняйтесь, бейте по пальцам и учите разуму, я не обидчивый.</i>
